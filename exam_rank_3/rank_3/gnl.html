<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GNL (42 Escola)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        h1 {
            color: #4ec9b0;
            margin-bottom: 30px;
            text-align: center;
            font-size: 2.5em;
        }
        h2 {
            color: #569cd6;
            margin-top: 40px;
            margin-bottom: 20px;
            border-bottom: 2px solid #569cd6;
            padding-bottom: 10px;
        }
        h3 {
            color: #dcdcaa;
            margin-top: 30px;
            margin-bottom: 15px;
        }
        .section {
            background: #252526;
            padding: 25px;
            margin-bottom: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        .comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        @media (max-width: 768px) {
            .comparison {
                grid-template-columns: 1fr;
            }
        }
        .code-block {
            background: #1e1e1e;
            border: 1px solid #3c3c3c;
            border-radius: 5px;
            padding: 15px;
            overflow-x: auto;
        }
        .wrong {
            border-left: 4px solid #f44336;
        }
        .correct {
            border-left: 4px solid #4caf50;
        }
        .code-title {
            font-weight: bold;
            margin-bottom: 10px;
            padding: 8px;
            border-radius: 3px;
        }
        .wrong .code-title {
            background: #f443361a;
            color: #f44336;
        }
        .correct .code-title {
            background: #4caf501a;
            color: #4caf50;
        }
        pre {
            margin: 0;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        code {
            font-family: 'Courier New', Courier, monospace;
            font-size: 14px;
            line-height: 1.5;
        }
        .explanation {
            background: #2d2d30;
            padding: 15px;
            margin: 15px 0;
            border-left: 4px solid #dcdcaa;
            border-radius: 3px;
        }
        .logic-flow {
            background: #2d2d30;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }
        .logic-step {
            padding: 10px;
            margin: 10px 0;
            background: #1e1e1e;
            border-left: 3px solid #4ec9b0;
            border-radius: 3px;
        }
        .highlight {
            color: #ce9178;
            font-weight: bold;
        }
        .keyword {
            color: #569cd6;
        }
        .function {
            color: #dcdcaa;
        }
        .comment {
            color: #6a9955;
        }
        .final-code {
            background: #0d1117;
            border: 2px solid #4caf50;
            padding: 20px;
            border-radius: 8px;
            margin-top: 30px;
        }
        ul, ol {
            margin-left: 25px;
            margin-top: 10px;
        }
        li {
            margin: 8px 0;
        }
        .critical {
            background: #4a2d2d;
            border-left: 4px solid #f44336;
            padding: 15px;
            margin: 15px 0;
            border-radius: 3px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üìö Guia Completo: Corre√ß√£o da GNL</h1>

        <div class="section">
            <h2>üéØ Objetivo do Exerc√≠cio</h2>
            <p>Criar uma fun√ß√£o que l√™ um arquivo linha por linha, retornando uma linha por vez (incluindo o '\n'). A fun√ß√£o deve:</p>
            <ul>
                <li>Retornar cada linha terminada em '\n' (ou EOF)</li>
                <li>Usar um buffer est√°tico para guardar dados entre chamadas</li>
                <li>N√£o ter memory leaks</li>
                <li>Retornar NULL ao terminar o arquivo (ap√≥s √∫ltima linha)</li>
            </ul>
        </div>

        <div class="section">
            <h2>üîç An√°lise dos Erros no C√≥digo da Prova</h2>

            <h3>1Ô∏è‚É£ Erro no ft_strchr</h3>
            <div class="comparison">
                <div class="code-block wrong">
                    <div class="code-title">‚ùå C√ìDIGO DA PROVA (ERRADO)</div>
                    <pre><code>char *ft_strchr(char *s, int c)
{
    int i = 0;
    while (s[i] != c)
        i++;
    if (s[i] == c)
        return (s + i);
    else
        return (NULL);
}</code></pre>
                </div>
                <div class="code-block correct">
                    <div class="code-title">‚úÖ C√ìDIGO CORRIGIDO</div>
                    <pre><code>char *ft_strchr(char *s, int c)
{
    int i;

    i = 0;
    while (s[i] && s[i] != c)
        i++;
    if (s[i] == c)
        return (s + i);
    return (NULL);
}</code></pre>
                </div>
            </div>
            <div class="explanation">
                <strong>‚ùå Problema:</strong> O loop n√£o verifica se chegou ao fim da string ('\0'). Se o caractere n√£o existir, continua lendo mem√≥ria inv√°lida ‚Üí <strong>SEGFAULT</strong><br><br>
                <strong>‚úÖ Solu√ß√£o:</strong> Adicionar <code>s[i] != '\0' &&</code> na condi√ß√£o do while.
            </div>

            <h3>2Ô∏è‚É£ Erro no ft_memcpy</h3>
            <div class="comparison">
                <div class="code-block wrong">
                    <div class="code-title">‚ùå C√ìDIGO DA PROVA (ERRADO)</div>
                    <pre><code>void *ft_memcpy(void *dest, const void *src, size_t n)
{
    while (--n > 0)
        ((char *)dest)[n - 1] = ((char *)src)[n - 1];
    return (dest);
}</code></pre>
                </div>
                <div class="code-block correct">
                    <div class="code-title">‚úÖ C√ìDIGO CORRIGIDO</div>
                    <pre><code>void *ft_memcpy(void *dest, const void *src, size_t n)
{
    size_t i;

    i = 0;
    while (i < n)
    {
        ((char *)dest)[i] = ((char *)src)[i];
        i++;
    }
    return (dest);
}</code></pre>
                </div>
            </div>
            <div class="explanation">
                <strong>‚ùå Problema:</strong> Decrementa <code>n</code> antes de usar, causando:<br>
                ‚Ä¢ Acesso a <code>[n-1]</code> quando <code>n</code> j√° foi decrementado ‚Üí √≠ndice errado<br>
                ‚Ä¢ N√£o copia o primeiro byte<br>
                ‚Ä¢ Acessa posi√ß√µes inv√°lidas<br><br>
                <strong>‚úÖ Solu√ß√£o:</strong> Loop crescente de 0 at√© n, copiando byte por byte.
            </div>

            <h3>3Ô∏è‚É£ Melhoria no ft_strlen</h3>
            <div class="comparison">
                <div class="code-block wrong">
                    <div class="code-title">‚ùå C√ìDIGO DA PROVA (VULNER√ÅVEL)</div>
                    <pre><code>size_t ft_strlen(char *s)
{
    size_t ret = 0;
    while (*s)
    {
        s++;
        ret++;
    }
    return (ret);
}</code></pre>
                </div>
                <div class="code-block correct">
                    <div class="code-title">‚úÖ C√ìDIGO CORRIGIDO</div>
                    <pre><code>size_t ft_strlen(char *s)
{
    size_t ret;

    if (!s)
        return (0);
    ret = 0;
    while (s[ret])
        ret++;
    return (ret);
}</code></pre>
                </div>
            </div>
            <div class="explanation">
                <strong>‚ùå Problema:</strong> Se receber NULL ‚Üí <strong>SEGFAULT</strong><br><br>
                <strong>‚úÖ Solu√ß√£o:</strong> Adicionar <code>if (!s) return (0);</code> no in√≠cio. Isso protege TODAS as outras fun√ß√µes que usam strlen!
            </div>

            <h3>4Ô∏è‚É£ Corre√ß√£o no str_append_mem</h3>
            <div class="comparison">
                <div class="code-block wrong">
                    <div class="code-title">‚ùå C√ìDIGO DA PROVA (INCOMPLETO)</div>
                    <pre><code>int str_append_mem(char **s1, char *s2, size_t size2)
{
    size_t size1 = ft_strlen(*s1);
    char *tmp = malloc(size2 + size1 + 1);
    if (!tmp)
        return (0);
    ft_memcpy(tmp, *s1, size1);
    ft_memcpy(tmp + size1, s2, size2);
    tmp[size1 + size2] = 0;
    free(*s1);
    *s1 = tmp;
    return (1);
}</code></pre>
                </div>
                <div class="code-block correct">
                    <div class="code-title">‚úÖ C√ìDIGO CORRIGIDO</div>
                    <pre><code>int str_append_mem(char **s1, char *s2, size_t size2)
{
    size_t size1;
    char *tmp;

    size1 = ft_strlen(*s1);
    tmp = malloc(size1 + size2 + 1);
    if (!tmp)
        return (0);
    if (*s1)
        ft_memcpy(tmp, *s1, size1);
    ft_memcpy(tmp + size1, s2, size2);
    tmp[size1 + size2] = 0;
    free(*s1);
    *s1 = tmp;
    return (1);
}</code></pre>
                </div>
            </div>
            <div class="explanation">
                <strong>‚ùå Problema:</strong> Se *s1 for NULL, faz <code>ft_memcpy(tmp, NULL, 0)</code> ‚Üí undefined behavior<br><br>
                <strong>‚úÖ Solu√ß√£o:</strong> Adicionar <code>if (*s1)</code> antes do primeiro memcpy.
            </div>

            <h3>5Ô∏è‚É£ Erro no ft_memmove</h3>
            <div class="comparison">
                <div class="code-block wrong">
                    <div class="code-title">‚ùå C√ìDIGO DA PROVA (ERRADO)</div>
                    <pre><code>void *ft_memmove(void *dest, const void *src, size_t n)
{
    if (dest > src)
        return (ft_memcpy(dest, src, n));
    else if (dest == src)
        return (dest);
    size_t i = ft_strlen((char *)src) - 1;
    while (i >= 0)
    {
        ((char *)dest)[i] = ((char *)src)[i];
        i--;
    }
    return (dest);
}</code></pre>
                </div>
                <div class="code-block correct">
                    <div class="code-title">‚úÖ C√ìDIGO CORRIGIDO</div>
                    <pre><code>void *ft_memmove(void *dest, const void *src, size_t n)
{
    size_t i;

    if (dest == src || n == 0)
        return (dest);
    if (dest < src)
        return (ft_memcpy(dest, src, n));
    i = n;
    while (i > 0)
    {
        i--;
        ((char *)dest)[i] = ((char *)src)[i];
    }
    return (dest);
}</code></pre>
                </div>
            </div>
            <div class="explanation">
                <strong>‚ùå Problemas:</strong><br>
                1. Usa <code>strlen</code> em dados bin√°rios (pode n√£o ter '\0')<br>
                2. Loop com <code>size_t</code> (unsigned) indo negativo ‚Üí overflow infinito<br>
                3. L√≥gica de sobreposi√ß√£o invertida (dest > src deveria copiar ao contr√°rio)<br><br>
                <strong>‚úÖ Solu√ß√£o:</strong><br>
                ‚Ä¢ Usar o tamanho <code>n</code> fornecido<br>
                ‚Ä¢ Se dest < src: sem risco de sobreposi√ß√£o, chamar memcpy<br>
                ‚Ä¢ Se dest > src: copiar do fim para o in√≠cio
            </div>

            <h3>6Ô∏è‚É£ ERRO CR√çTICO no get_next_line</h3>
            <div class="critical">
                ‚ö†Ô∏è ESTE √â O ERRO MAIS IMPORTANTE! S√£o 2 problemas que voc√™ DEVE corrigir.
            </div>
            <div class="comparison">
                <div class="code-block wrong">
                    <div class="code-title">‚ùå C√ìDIGO DA PROVA (2 ERROS)</div>
                    <pre><code>char *get_next_line(int fd)
{
    static char b[BUFFER_SIZE + 1] = "";
    char *ret = NULL;
    char *tmp = ft_strchr(b, '\n');
    while (!tmp)
    {
        if (!str_append_str(&ret, b))
            return (NULL);
        int read_ret = read(fd, b, BUFFER_SIZE);
        if (read_ret == -1)
            return (NULL);
        b[read_ret] = 0;
    }
    if (!str_append_mem(&ret, b, tmp - b + 1))
    {
        free(ret);
        return (NULL);
    }
    <span class="comment">/* ‚ùå ERRO 1: FALTA MOVER O BUFFER! */</span>
    return (ret);
}</code></pre>
                </div>
                <div class="code-block correct">
                    <div class="code-title">‚úÖ C√ìDIGO CORRIGIDO</div>
                    <pre><code>char *get_next_line(int fd)
{
    static char b[BUFFER_SIZE + 1] = "";
    char *ret = NULL;
    char *tmp;
    int read_ret;

    while (!(tmp = ft_strchr(b, '\n')))
    {
        if (!str_append_str(&ret, b))
            return (NULL);
        read_ret = read(fd, b, BUFFER_SIZE);
        if (read_ret <= 0)
        {
            b[0] = 0;
            <span class="comment">/* ‚úÖ CORRE√á√ÉO 1: Tratar EOF vazio */</span>
            if (read_ret == -1 || !ret || !*ret)
            {
                free(ret);
                return (NULL);
            }
            return (ret);
        }
        b[read_ret] = 0;
    }
    if (!str_append_mem(&ret, b, tmp - b + 1))
    {
        free(ret);
        return (NULL);
    }
    <span class="comment">/* ‚úÖ CORRE√á√ÉO 2: Mover buffer */</span>
    ft_memmove(b, tmp + 1, ft_strlen(tmp + 1) + 1);
    return (ret);
}</code></pre>
                </div>
            </div>
            <div class="critical">
                <strong>‚ùå ERRO 1:</strong> N√£o trata EOF quando arquivo est√° vazio ou ret est√° vazio<br>
                ‚Ä¢ Se read retorna 0 mas ret √© NULL ou "", deve retornar NULL<br>
                ‚Ä¢ Sem isso, retorna ponteiro inv√°lido<br><br>
                <strong>‚úÖ CORRE√á√ÉO 1:</strong> <code>if (read_ret == -1 || !ret || !*ret)</code><br><br>

                <strong>‚ùå ERRO 2:</strong> N√£o move o resto do buffer para o in√≠cio!<br>
                ‚Ä¢ Buffer: "linha1\nlinha2\n"<br>
                ‚Ä¢ Retorna: "linha1\n"<br>
                ‚Ä¢ Buffer fica inalterado ‚Üí pr√≥xima chamada retorna "linha1\n" de novo!<br><br>
                <strong>‚úÖ CORRE√á√ÉO 2:</strong> <code>ft_memmove(b, tmp + 1, ft_strlen(tmp + 1) + 1);</code>
            </div>
        </div>

        <div class="section">
            <h2>üß† L√≥gica da Solu√ß√£o</h2>
            <div class="logic-flow">
                <div class="logic-step">
                    <strong>PASSO 1:</strong> Procurar '\n' no buffer est√°tico
                </div>
                <div class="logic-step">
                    <strong>PASSO 2:</strong> Enquanto N√ÉO encontrar '\n':
                    <ul>
                        <li>Adicionar todo o buffer ao resultado</li>
                        <li>Ler mais BUFFER_SIZE bytes do arquivo</li>
                        <li>Se read ‚â§ 0: tratar EOF/erro</li>
                        <li>Adicionar '\0' no fim do buffer</li>
                    </ul>
                </div>
                <div class="logic-step">
                    <strong>PASSO 3:</strong> Quando encontrar '\n':
                    <ul>
                        <li>Adicionar do buffer at√© '\n' (inclusive) ao resultado</li>
                        <li><strong>CR√çTICO:</strong> Mover o resto do buffer para o in√≠cio</li>
                        <li>Retornar a linha completa</li>
                    </ul>
                </div>
            </div>

            <h3>üìå Detalhando as corre√ß√µes cr√≠ticas:</h3>
            <div class="explanation">
                <strong>Corre√ß√£o 1 - Tratamento de EOF:</strong><br>
                <code>if (read_ret == -1 || !ret || !*ret)</code><br><br>
                ‚Ä¢ <code>read_ret == -1</code> ‚Üí erro de leitura<br>
                ‚Ä¢ <code>!ret</code> ‚Üí ret √© NULL (nunca alocou)<br>
                ‚Ä¢ <code>!*ret</code> ‚Üí ret √© string vazia "" (arquivo vazio)<br><br>

                <strong>Corre√ß√£o 2 - Mover buffer:</strong><br>
                <code>ft_memmove(b, tmp + 1, ft_strlen(tmp + 1) + 1);</code><br><br>
                ‚Ä¢ <code>b</code> ‚Üí destino (in√≠cio do buffer)<br>
                ‚Ä¢ <code>tmp + 1</code> ‚Üí origem (pula o '\n')<br>
                ‚Ä¢ <code>ft_strlen(tmp + 1)</code> ‚Üí tamanho do resto<br>
                ‚Ä¢ <code>+ 1</code> ‚Üí inclui o '\0' final<br><br>

                <strong>Exemplo:</strong><br>
                Buffer = "abc\ndefgh"<br>
                ‚Ä¢ tmp aponta para '\n'<br>
                ‚Ä¢ tmp + 1 aponta para 'd'<br>
                ‚Ä¢ ft_strlen(tmp + 1) = 5<br>
                ‚Ä¢ + 1 = 6 (copia o '\0')<br>
                ‚Ä¢ Resultado: buffer = "defgh"
            </div>
        </div>

        <div class="section">
            <h2>üìù C√≥digo Final Completo e Comentado</h2>

            <div class="final-code">
                <h3>get_next_line.h</h3>
                <pre><code><span class="keyword">#ifndef</span> GET_NEXT_LINE_H
<span class="keyword"># define</span> GET_NEXT_LINE_H

<span class="keyword">#include</span> &lt;stdlib.h&gt;
<span class="keyword">#include</span> &lt;unistd.h&gt;

<span class="keyword">#ifndef</span> BUFFER_SIZE
<span class="keyword"># define</span> BUFFER_SIZE 42
<span class="keyword">#endif</span>

<span class="keyword">char</span>	*<span class="function">get_next_line</span>(<span class="keyword">int</span> fd);

<span class="keyword">#endif</span></code></pre>
            </div>

            <div class="final-code">
                <h3>get_next_line.c</h3>
                <pre><code><span class="keyword">#include</span> "get_next_line.h"

<span class="comment">/* Procura um caractere em uma string */</span>
<span class="keyword">char</span>	*<span class="function">ft_strchr</span>(<span class="keyword">char</span> *s, <span class="keyword">int</span> c)
{
	<span class="keyword">int</span>	i;

	i = 0;
	<span class="comment">/* Verifica '\0' para n√£o ler al√©m da string */</span>
	<span class="keyword">while</span> (s[i] && s[i] != c)
		i++;
	<span class="keyword">if</span> (s[i] == c)
		<span class="keyword">return</span> (s + i);
	<span class="keyword">return</span> (NULL);
}

<span class="comment">/* Copia n bytes de src para dest */</span>
<span class="keyword">void</span>	*<span class="function">ft_memcpy</span>(<span class="keyword">void</span> *dest, <span class="keyword">const void</span> *src, <span class="keyword">size_t</span> n)
{
	<span class="keyword">size_t</span>	i;

	i = 0;
	<span class="comment">/* Loop crescente: copia byte por byte */</span>
	<span class="keyword">while</span> (i < n)
	{
		((<span class="keyword">char</span> *)dest)[i] = ((<span class="keyword">char</span> *)src)[i];
		i++;
	}
	<span class="keyword">return</span> (dest);
}

<span class="comment">/* Calcula o tamanho da string */</span>
<span class="keyword">size_t</span>	<span class="function">ft_strlen</span>(<span class="keyword">char</span> *s)
{
	<span class="keyword">size_t</span>	ret;

	<span class="comment">/* Prote√ß√£o contra NULL */</span>
	<span class="keyword">if</span> (!s)
		<span class="keyword">return</span> (0);
	ret = 0;
	<span class="keyword">while</span> (s[ret])
		ret++;
	<span class="keyword">return</span> (ret);
}

<span class="comment">/* Adiciona size2 bytes de s2 ao final de s1 */</span>
<span class="keyword">int</span>	<span class="function">str_append_mem</span>(<span class="keyword">char</span> **s1, <span class="keyword">char</span> *s2, <span class="keyword">size_t</span> size2)
{
	<span class="keyword">size_t</span>	size1;
	<span class="keyword">char</span>	*tmp;

	size1 = <span class="function">ft_strlen</span>(*s1);
	tmp = <span class="function">malloc</span>(size1 + size2 + 1);
	<span class="keyword">if</span> (!tmp)
		<span class="keyword">return</span> (0);
	<span class="comment">/* S√≥ copia se *s1 existir */</span>
	<span class="keyword">if</span> (*s1)
		<span class="function">ft_memcpy</span>(tmp, *s1, size1);
	<span class="function">ft_memcpy</span>(tmp + size1, s2, size2);
	tmp[size1 + size2] = <span class="highlight">0</span>;
	<span class="function">free</span>(*s1);
	*s1 = tmp;
	<span class="keyword">return</span> (1);
}

<span class="comment">/* Adiciona string completa s2 ao final de s1 */</span>
<span class="keyword">int</span>	<span class="function">str_append_str</span>(<span class="keyword">char</span> **s1, <span class="keyword">char</span> *s2)
{
	<span class="keyword">return</span> (<span class="function">str_append_mem</span>(s1, s2, <span class="function">ft_strlen</span>(s2)));
}

<span class="comment">/* Move n bytes de src para dest (lida com sobreposi√ß√£o) */</span>
<span class="keyword">void</span>	*<span class="function">ft_memmove</span>(<span class="keyword">void</span> *dest, <span class="keyword">const void</span> *src, <span class="keyword">size_t</span> n)
{
	<span class="keyword">size_t</span>	i;

	<span class="keyword">if</span> (dest == src || n == 0)
		<span class="keyword">return</span> (dest);
	<span class="comment">/* Se dest < src: sem sobreposi√ß√£o, usa memcpy */</span>
	<span class="keyword">if</span> (dest < src)
		<span class="keyword">return</span> (<span class="function">ft_memcpy</span>(dest, src, n));
	<span class="comment">/* Se dest > src: copia do fim para o in√≠cio */</span>
	i = n;
	<span class="keyword">while</span> (i > 0)
	{
		i--;
		((<span class="keyword">char</span> *)dest)[i] = ((<span class="keyword">char</span> *)src)[i];
	}
	<span class="keyword">return</span> (dest);
}

<span class="comment">/* FUN√á√ÉO PRINCIPAL: L√™ e retorna a pr√≥xima linha */</span>
<span class="keyword">char</span>	*<span class="function">get_next_line</span>(<span class="keyword">int</span> fd)
{
	<span class="comment">/* Buffer est√°tico: mant√©m dados entre chamadas */</span>
	<span class="keyword">static char</span>	b[BUFFER_SIZE + 1] = "";
	<span class="keyword">char</span>		*ret;
	<span class="keyword">char</span>		*tmp;
	<span class="keyword">int</span>		read_ret;

	ret = NULL;
	<span class="comment">/* Loop: enquanto n√£o encontrar '\n' */</span>
	<span class="keyword">while</span> (!(tmp = <span class="function">ft_strchr</span>(b, <span class="highlight">'\n'</span>)))
	{
		<span class="comment">/* Adiciona todo o buffer ao resultado */</span>
		<span class="keyword">if</span> (!<span class="function">str_append_str</span>(&ret, b))
			<span class="keyword">return</span> (NULL);
		<span class="comment">/* L√™ mais dados do arquivo */</span>
		read_ret = <span class="function">read</span>(fd, b, BUFFER_SIZE);
		<span class="comment">/* Se EOF ou erro */</span>
		<span class="keyword">if</span> (read_ret <= 0)
		{
			b[0] = <span class="highlight">0</span>; <span class="comment">/* Limpa buffer */</span>
			<span class="comment">/* Se erro OU ret vazio: retorna NULL */</span>
			<span class="keyword">if</span> (read_ret == -1 || !ret || !*ret)
			{
				<span class="function">free</span>(ret);
				<span class="keyword">return</span> (NULL);
			}
			<span class="keyword">return</span> (ret); <span class="comment">/* Retorna √∫ltima linha */</span>
		}
		b[read_ret] = <span class="highlight">0</span>; <span class="comment">/* Termina string */</span>
	}
	<span class="comment">/* Encontrou '\n': adiciona at√© '\n' (inclusive) */</span>
	<span class="keyword">if</span> (!<span class="function">str_append_mem</span>(&ret, b, tmp - b + 1))
	{
		<span class="function">free</span>(ret);
		<span class="keyword">return</span> (NULL);
	}
	<span class="comment">/* CR√çTICO: Move o resto do buffer para o in√≠cio */</span>
	<span class="function">ft_memmove</span>(b, tmp + 1, <span class="function">ft_strlen</span>(tmp + 1) + 1);
	<span class="keyword">return</span> (ret);
}</code></pre>
            </div>
        </div>

        <div class="section">
            <h2>üéì Resumo para Memorizar</h2
            <div class="logic-flow">
                <h3>6 Erros que voc√™ PRECISA corrigir:</h3>
                <ol>
                    <li><strong>ft_strchr:</strong> Adicionar <code>s[i] != '\0'</code> no while</li>
                    <li><strong>ft_memcpy:</strong> Loop crescente: <code>i = 0; i < n; i++</code></li>
                    <li><strong>ft_strlen:</strong> Retornar 0 se <code>!s</code></li>
<li><strong>str_append_mem:</strong> Verificar <code>if (*s1)</code> antes do memcpy</li>
<li><strong>ft_memmove:</strong> Se <code>dest < src</code> chamar memcpy; sen√£o copiar do fim</li>
<li><strong>get_next_line:</strong> Adicionar <code>ft_memmove(b, tmp + 1, ft_strlen(tmp + 1) + 1)</code> no final</li>
</ol>

            <h3 style="margin-top: 30px;">O Erro Mais Cr√≠tico:</h3>
            <div class="critical">
                <strong>SEMPRE MOVER O BUFFER ap√≥s encontrar '\n'!</strong><br><br>
                <code>ft_memmove(b, tmp + 1, ft_strlen(tmp + 1) + 1);</code><br><br>
                Sem isso, voc√™ perde os dados que sobraram no buffer!
            </div>

            <h3 style="margin-top: 30px;">Teste Mental R√°pido:</h3>
            <p><strong>Arquivo: "abc\ndef\n"</strong></p>
            <ul>
                <li>Leitura 1: buffer = "abc\ndef\n"</li>
                <li>Retorna: "abc\n"</li>
                <li>Ap√≥s memmove: buffer = "def\n"</li>
                <li>Leitura 2: retorna "def\n"</li>
                <li>Ap√≥s memmove: buffer = ""</li>
                <li>Leitura 3: retorna NULL</li>
            </ul>
        </div>
    </div>

    <div class="section" style="background: #1a472a; border: 2px solid #4caf50;">
        <h2 style="color: #4caf50;">‚úÖ Checklist Final da Prova</h2>
        <ul style="font-size: 1.1em;">
            <li>‚òê <strong>ft_strchr:</strong> while com <code>s[i] != '\0' && s[i] != c</code></li>
            <li>‚òê <strong>ft_memcpy:</strong> loop <code>i = 0; i < n; i++</code></li>
            <li>‚òê <strong>ft_strlen:</strong> <code>if (!s) return (0);</code> no in√≠cio</li>
            <li>‚òê <strong>str_append_mem:</strong> <code>if (*s1)</code> antes do primeiro memcpy</li>
            <li>‚òê <strong>ft_memmove:</strong> <code>if (dest < src) return ft_memcpy(...)</code></li>
            <li>‚òê <strong>get_next_line:</strong> <code>ft_memmove(b, tmp + 1, ft_strlen(tmp + 1) + 1);</code> antes do return</li>
        </ul>
    </div>

</div>
</body>
</html>
