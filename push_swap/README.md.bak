# üìö Push Swap ‚Äî Guia Completo de Avalia√ß√£o

## üìã √çndice
1. [Objetivo do Projeto](#objetivo)
2. [Regras e Restri√ß√µes](#regras)
3. [Estrutura do Projeto](#estrutura)
4. [Algoritmo Explicado](#algoritmo)
5. [Implementa√ß√£o Detalhada](#implementacao)
6. [Otimiza√ß√µes e M√©tricas](#metricas)
7. [Como Testar](#testes)
8. [Checklist de Avalia√ß√£o](#checklist)

---

## üéØ Objetivo

O projeto **push_swap** consiste em:

1. **Programa `push_swap`**: Recebe uma lista de n√∫meros inteiros na linha de comando e imprime uma sequ√™ncia de opera√ß√µes que ordena uma pilha A em ordem crescente.
2. **Programa `checker`** (opcional): Valida se uma sequ√™ncia de opera√ß√µes realmente ordena a pilha.

### Entrada
```bash
./push_swap 3 2 1 5 4
```

### Sa√≠da esperada
```
pb
rb
pb
ra
pa
pa
```

### Valida√ß√£o
```bash
./push_swap 3 2 1 5 4 | ./checker 3 2 1 5 4
# Sa√≠da: OK ou KO
```

---

## ‚öôÔ∏è Regras

### ‚úÖ Opera√ß√µes Permitidas

| Opera√ß√£o | Descri√ß√£o |
|----------|-----------|
| `sa` | Swap: troca os 2 primeiros elementos de A |
| `sb` | Swap: troca os 2 primeiros elementos de B |
| `ss` | Swap: `sa` + `sb` simultaneamente |
| `pa` | Push: move o topo de B para o topo de A |
| `pb` | Push: move o topo de A para o topo de B |
| `ra` | Rotate: move todos de A uma posi√ß√£o para cima (head ‚Üí tail) |
| `rb` | Rotate: move todos de B uma posi√ß√£o para cima (head ‚Üí tail) |
| `rr` | Rotate: `ra` + `rb` simultaneamente |
| `rra` | Reverse Rotate: move todos de A uma posi√ß√£o para baixo (tail ‚Üí head) |
| `rrb` | Reverse Rotate: move todos de B uma posi√ß√£o para baixo (tail ‚Üí head) |
| `rrr` | Reverse Rotate: `rra` + `rrb` simultaneamente |

### ‚õî Restri√ß√µes

- N√∫meros devem estar **dentro do intervalo de `int`** (-2,147,483,648 a 2,147,483,647)
- **Sem duplicatas** permitidas
- **Sem fun√ß√µes prontas** de ordena√ß√£o (`qsort`, etc.)
- **Sem vazamento de mem√≥ria** (validar com Valgrind)
- **Norminette** obrigat√≥ria (estilo da 42)
- **Sem warnings** na compila√ß√£o (`-Wall -Wextra -Werror`)

---

## üìÅ Estrutura

```
push_swap/
‚îú‚îÄ‚îÄ Makefile                  # Compila√ß√£o
‚îú‚îÄ‚îÄ README.md                 # Este arquivo
‚îú‚îÄ‚îÄ includes/
‚îÇ   ‚îî‚îÄ‚îÄ push_swap.h          # Headers e prot√≥tipos
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ main.c               # Fluxo principal
‚îÇ   ‚îú‚îÄ‚îÄ parse_*.c            # Parsing e valida√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ ops_*.c              # Opera√ß√µes (sa, pb, ra, etc)
‚îÇ   ‚îú‚îÄ‚îÄ sort_*.c             # Algoritmos de ordena√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ pull_b.c             # Reinser√ß√£o de B‚ÜíA
‚îÇ   ‚îú‚îÄ‚îÄ small_cases.c        # Casos 4 e 5
‚îÇ   ‚îú‚îÄ‚îÄ utils_*.c            # Fun√ß√µes auxiliares
‚îÇ   ‚îú‚îÄ‚îÄ checker.c            # Programa checker
‚îÇ   ‚îî‚îÄ‚îÄ checker_ops.c        # Opera√ß√µes do checker
‚îî‚îÄ‚îÄ libft/                   # Biblioteca auxiliar
    ‚îú‚îÄ‚îÄ dlist.h              # Lista duplamente ligada
    ‚îî‚îÄ‚îÄ [+60 fun√ß√µes]        # String, memory, printf, etc
```

### Arquivos Principais por Funcionalidade

#### üîß **Parsing e Valida√ß√£o**
- `parse_main.c` ‚Äî Fun√ß√£o principal de parsing
- `parse_tokens.c` ‚Äî Tokeniza√ß√£o de argumentos
- `parse_checks.c` ‚Äî Verifica√ß√£o de duplicatas
- `parse_index.c` ‚Äî Indexa√ß√£o (0..n-1)
- `utils_num.c` ‚Äî Valida√ß√£o de n√∫meros
- `utils_checks.c` ‚Äî Verifica√ß√µes gerais

#### ‚öôÔ∏è **Opera√ß√µes da Pilha**
- `ops_swap.c` ‚Äî `sa`, `sb`, `ss`
- `ops_push.c` ‚Äî `pa`, `pb` + helpers
- `ops_rotate.c` ‚Äî `ra`, `rb`, `rr`
- `ops_rev_rotate.c` ‚Äî `rra`, `rrb`, `rrr`

#### üéØ **Algoritmos de Ordena√ß√£o**
- `sort_small.c` ‚Äî Casos 2 e 3 (√≥timo)
- `small_cases.c` ‚Äî Casos 4 e 5 (estrat√©gia de menores para B)
- `sort_many.c` ‚Äî Chunking para n>5
- `sort_router.c` ‚Äî Escolhe o melhor algoritmo

#### üîé **Busca e Utilidades**
- `utils_search.c` ‚Äî `find_min_value()`, `find_position()`, `distance_to_top()`
- `utils_nodes.c` ‚Äî Opera√ß√µes em n√≥s
- `utils_mem.c` ‚Äî Libera√ß√£o de mem√≥ria
- `stack_utils.c` ‚Äî Inicializa√ß√£o e limpeza de stack

#### ‚úîÔ∏è **Checker Local**
- `checker.c` ‚Äî Main do checker
- `checker_ops.c` ‚Äî Aplica√ß√£o de opera√ß√µes

---

## üß† Algoritmo Explicado



### üî∑ Fluxo Geral

```
1. PARSING
   - Ler argumentos
   - Validar n√∫meros (overflow, n√£o-num√©ricos)
   - Detectar duplicatas
   - Criar pilha A com valores

2. INDEXA√á√ÉO (0..n-1)
   - Converter valores para √≠ndices
   - √çndice 0 = menor valor
   - √çndice n-1 = maior valor

3. ESCOLHER ALGORITMO
   - n=2 ‚Üí sort_2()
   - n=3 ‚Üí sort_3()
   - n=4,5 ‚Üí handle_small_cases()
   - n>5 ‚Üí sort_many() (chunking)

4. EXECUTAR ORDENA√á√ÉO
   - Gerar sequ√™ncia de opera√ß√µes
   - Imprimir cada uma

5. LIBERAR MEM√ìRIA
   - Destruir pilhas A e B
   - Fazer clean exit
```

### üéØ Estrat√©gia por Tamanho

#### **n=2: sort_2()**
```
if a[0] > a[1]:
    sa()
```
- M√°ximo: 1 opera√ß√£o

#### **n=3: sort_3()**
```
An√°lise dos 3 primeiros valores:
- Se j√° ordenado: nenhuma op
- Se a[0]>a[1]>a[2]: sa + rra
- Se a[1]>a[2]>a[0]: ra
- etc... (5 casos poss√≠veis)
```
- M√°ximo: 2 opera√ß√µes

#### **n=4,5: handle_small_cases()**

**Estrat√©gia:**
1. Encontre o menor elemento em A
2. Rotacione para o topo (`ra` ou `rra` ‚Äî escolha o mais curto)
3. Empurre para B com `pb`
4. Repita se n=5 (move os 2 menores)
5. Ordene os 3 restantes em A com `sort_3()`
6. Traga de volta de B com `pa` (uma ou duas vezes)

**Exemplo n=4:**
```
Entrada: [3, 2, 5, 1] (√≠ndices: [2, 1, 3, 0])

Step 1: Encontre m√≠nimo (√≠ndice 0, posi√ß√£o 3)
Step 2: Rotacione com rra 1 vez ‚Üí [1, 3, 2, 5]
Step 3: pb ‚Üí A=[3, 2, 5], B=[1]
Step 4: sort_3(A) ‚Üí A=[2, 3, 5]
Step 5: pa ‚Üí A=[1, 2, 3, 5] ‚úì
```

#### **n>5: sort_many() ‚Äî Chunking**

**Ideia Principal:**
Dividir A em blocos (chunks) e empurrar para B de forma controlada, depois reinserir do maior para o menor.

**Par√¢metros:**
- `chunks = 5` se n ‚â§ 100
- `chunks = 11` se n > 100
- `chunk_size = n / chunks`

**Fase 1: A ‚Üí B (Push com chunking)**

```
pushed_count = 0

while A n√£o est√° vazia:
    if topo de A <= pushed_count:
        // Elemento j√° foi "visto", est√° no bloco passado
        pb()
        rb()  // Coloca no fundo de B
    elif topo de A <= pushed_count + chunk_size:
        // Elemento pertence ao chunk atual
        pb()
    else:
        // Elemento √© do chunk futuro
        ra()  // Gira A at√© trazer do chunk certo

    Se terminou um chunk:
        pushed_count += chunk_size
```

**Fase 2: B ‚Üí A (Pull do maior para o menor)**

```
for value = n-1 down to 0:
    Encontre a posi√ß√£o de 'value' em B
    move_to_top_b()    // Usa rb ou rrb (o mais curto)
    pa()               // Move para A
    
// Resultado: A completamente ordenada
```

**Exemplo Pr√°tico (n=10, chunks=5):**

```
Entrada indexada: [3, 8, 1, 9, 0, 5, 2, 7, 4, 6]
chunk_size = 10/5 = 2

BLOCO 0 (√≠ndices 0-1): [3, 8, 1, 9] ‚Üí traz 0,1
BLOCO 1 (√≠ndices 2-3): [5, 2] ‚Üí traz 2,3
BLOCO 2 (√≠ndices 4-5): [7, 4] ‚Üí traz 4,5
etc.

Ao final:
A = []
B = [todos em ordem de blocos]

Reinser√ß√£o (maiores primeiro):
- Traz 9 ‚Üí A = [9]
- Traz 8 ‚Üí A = [8, 9]
- Traz 7 ‚Üí A = [7, 8, 9]
... at√© A = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] ‚úì
```

---

## üíª Implementa√ß√£o Detalhada

1. Aceitar tanto argumentos separados quanto uma string com v√°rios n√∫meros. Exemplo v√°lido:

   ./push_swap "2 1 3"   # ou ./push_swap 2 1 3

2. Ignorar espa√ßos extras e controlar sinais.

3. Verificar overflow: use `long` ao converter (ou `ft_atol`) e rejeite se fora do intervalo de `int`.

4. Rejeitar entradas n√£o-num√©ricas: `./push_swap 1 2 a` -> erro.

5. Rejeitar duplicatas ‚Äî antes de indexar/ordenar, verifique duplicatas.

6. Em caso de erro: imprimir `Error` na sa√≠da padr√£o de erro e terminar com c√≥digo != 0 (seguindo a norma da 42 costuma ser `write(2, "Error\n", 6)` e `exit(1)`).

## 7 ‚Äî Representa√ß√£o interna recomendada

- Pilhas A e B como listas duplamente ligadas (dlist) ou arrays com rota√ß√£o l√≥gica. Este projeto usa `t_dlist` e `t_dnode` na `libft`.
- Cada n√≥ guarda o valor original e, opcionalmente, o √≠ndice (posi√ß√£o na ordem ordenada). O √≠ndice √© √∫til para radian sort e chunking.

## 8 ‚Äî Estrat√©gias por tamanho

8.1 Casos triviais (2, 3)

- `sort_2`: se primeiro > segundo -> `sa`.
- `sort_3`: analisar 3 valores e aplicar at√© 2 opera√ß√µes (sa/ra/rra) ‚Äî existem 5 casos.

8.2 Casos de 4 e 5 (detalhado ‚Äî bastante importante para a avalia√ß√£o)

- Estrat√©gia cl√°ssica para 4:
  1. Encontre a posi√ß√£o do menor elemento.
  2. Rote ele para o topo com `ra`/`rra` (menor n√∫mero entre rota√ß√µes).
  3. `pb` (envia para B).
  4. `sort_3` em A.
  5. `pa` (volta o menor).

- Estrat√©gia cl√°ssica para 5:
  1. Repetir o processo de mover o menor para B duas vezes (colocar os dois menores em B).
  2. `sort_3` em A.
  3. `pa` duas vezes (retornando do menor para o topo). Se necess√°rio, ajustar com `sa`.

Essas estrat√©gias costumam ser aceitas como corretas e eficientes para a avalia√ß√£o. Verifique sempre se voc√™ est√° empurrando os menores ‚Äî por isso indexar a pilha (0..n-1) ajuda.

8.3 Muitos elementos ‚Äî duas abordagens comprovadas

- Radix por √≠ndice (base 2):
  - Indexe os valores de 0..n-1 (menor recebe 0, maior n-1).
  - Para cada bit (0..max_bits): percorra A, envie `pb` se o bit em quest√£o for 0, caso contr√°rio `ra`.
  - Ao fim de cada bit, `pa` at√© B ficar vazia. Complexidade O(n * max_bits).
  - Simples de implementar e com comportamento est√°vel at√© n=500 com contagem aceit√°vel de opera√ß√µes.

- Chunking / divis√£o por blocos:
  - Divida a sequ√™ncia indexada em blocos (chunks). Por exemplo, para n=100 pode usar 5 a 8 chunks.
  - Percorra A e envie para B os elementos cujo √≠ndice pertence ao bloco atual, movendo-os de forma a minimizar rota√ß√µes.
  - Ao puxar de B para A, sempre traga o maior dispon√≠vel para o topo (para montar a pilha final ordenada). Usa `rb`/`rrb` para posicionar.
  - Requer mais ajuste fino (tamanho dos chunks, heur√≠sticas) mas tende a produzir menos opera√ß√µes se bem feito.

## 9 ‚Äî Dicas de otimiza√ß√£o (reduzir n√∫mero de opera√ß√µes)

- Sempre indexe os n√∫meros: trabalhar com √≠ndices torna compara√ß√µes e decis√µes de chunk/radix triviais.
- Para mover um elemento a partir de posi√ß√£o p ao topo, escolha entre `ra` p vezes ou `rra` (size-p) vezes‚Äîescolha o menor custo.
- Ao empurrar elementos para B durante chunking, tente posicionar os elementos de B para que o melhor candidato seja f√°cil de puxar (usar `rb` logo ap√≥s `pb` quando faz sentido).
- Evite opera√ß√µes desnecess√°rias (`ra` seguido por `rra` √© redundante). Ap√≥s gerar a sequ√™ncia, pode-se tentar um pass de otimiza√ß√£o que elimina pares inversos (e.g., `ra` + `rra`).

## 10 ‚Äî Implementa√ß√£o das opera√ß√µes (conselhos pr√°ticos)

- Cada opera√ß√£o deve atualizar corretamente `head`, `tail`, `size` de cada lista.
- `sa/sb`: trocar os dois primeiros nodes se existirem pelo menos 2.
- `pa/pb`: copiar o valor do topo da pilha fonte para destino ‚Äî cuide de aloca√ß√£o e desaloca√ß√£o (neste projeto, a libft parece usar duplica√ß√£o de int e gerenciamento via `free_int`).
- `ra/rb/rr`: mover head para tail (rotacionar para cima).
- `rra/rrb/rrr`: mover tail para head (rotacionar para baixo).

Imprima as opera√ß√µes exatamente como strings com newline (e.g., `write(1, "ra\n", 3)`).

## 11 ‚Äî Fun√ß√µes refatoradas e documentadas (NOV/2025)

As seguintes fun√ß√µes foram refatoradas com coment√°rios linha por linha explicando cada etapa:

### `small_cases.c` ‚Äî Trata casos de 4 e 5 elementos

- **`bring_min_to_top_and_pb(t_stack *stack)`**
  - Encontra o menor elemento em A usando `find_min_value()`.
  - Calcula a posi√ß√£o com `find_position()`.
  - Escolhe entre `ra` (rota√ß√µes para cima) ou `rra` (rota√ß√µes para baixo) conforme qual √© mais curto.
  - Executa `pb` para enviar o m√≠nimo para B.
  - **Caso 4**: remove 1 m√≠nimo, ordena 3 em A com `sort_3()`, volta com `pa`.
  - **Caso 5**: remove 2 m√≠nimos em sequ√™ncia, ordena 3 em A, volta com dois `pa`.

- **`handle_small_cases(t_stack *stack, int size)`**
  - Detecta se o tamanho √© 4 ou 5.
  - Executa a estrat√©gia acima e retorna 1 (sucesso) ou 0 (tamanho n√£o √© 4/5).

### `pull_b.c` ‚Äî Segunda fase: reinser√ß√£o de B para A

- **`move_to_top_b(t_stack *stack, int position)`**
  - Traz um elemento em posi√ß√£o `position` de B para o topo.
  - Calcula se √© mais r√°pido usar `rb` (rota√ß√£o para cima) ou `rrb` (rota√ß√£o para baixo).
  - Crit√©rio: se `position <= size/2`, usa `rb` `position` vezes; caso contr√°rio, usa `rrb` `(size - position)` vezes.

- **`phase_pull_b_to_a(t_stack *stack, int size)`**
  - Itera de `size-1` at√© `0` (do maior para o menor em B).
  - Para cada valor, encontra sua posi√ß√£o em B com `find_position()`.
  - Move para o topo com `move_to_top_b()`.
  - Executa `pa` para trazer para A.
  - **Resultado**: A fica completamente ordenada (maiores foram inseridos primeiro, mantendo a ordem).

### `parse_index.c` ‚Äî Indexa√ß√£o de valores (0..n-1)

- **`bubble_sort(int *arr, int n)`**
  - Ordena um array tempor√°rio usando bubble sort.
  - Usado para construir a sequ√™ncia ordenada dos valores.

- **`build_sorted_array(t_dlist *a)`**
  - Copia todos os valores de A para um array din√¢mico.
  - Chama `bubble_sort()` para ordenar.
  - Retorna o array ordenado (usado como refer√™ncia).

- **`assign_indices(t_dlist *a, int *sorted_arr)`**
  - Percorre A e substitui cada valor pelo seu √≠ndice relativo (0..n-1).
  - √çndice 0 = menor valor, √≠ndice n-1 = maior valor.
  - Essencial para estrat√©gias de chunking e radix.

- **`ps_index_stack(t_stack *stack)`**
  - Fun√ß√£o p√∫blica que orquestra a indexa√ß√£o completa.

## 12 ‚Äî Verifica√ß√µes finais antes de submeter

1. Compilar sem warnings: `make` com `-Wall -Wextra -Werror` deve passar.
2. Norminette: corrija estilo conforme normas da 42 (nomes de fun√ß√µes, tamanho de linhas, arquivos, etc.).
3. Teste exaustivo para n=2..5 (todas permuta√ß√µes).
4. Teste com vetores maiores t√≠picos (100 e 500) e compare com solu√ß√µes p√∫blicas apenas para refer√™ncia (n√£o copie!).
5. Rodar valgrind (ou equivalente) para garantir aus√™ncia de leaks:

```bash
valgrind --leak-check=full ./push_swap 3 2 1
```

6. Certifique-se de que sua execu√ß√£o n√£o imprime nada al√©m das opera√ß√µes (nenhuma mensagem de debug na sa√≠da padr√£o).

## 13 ‚Äî Erros comuns e como evit√°-los

- Duplicatas n√£o detectadas: verifique a lista inteira antes de come√ßar a ordenar.
- Overflow ao converter argumentos: use `long` tempor√°rio.
- Opera√ß√µes impressas mesmo em erros: imprima `Error` apenas e encerre.
- Esquecer de atualizar `size`/`head`/`tail` em opera√ß√µes ‚Äî causa corrup√ß√£o da lista.
- Libertar mem√≥ria: free em todos os paths (parsing com erro, sucesso, etc.).

## 14 ‚Äî Estrat√©gia de desenvolvimento recomendada (passo a passo)

1. Implementar parsing e valida√ß√£o (tests unit√°rios simples).
2. Implementar `dlist` e opera√ß√µes b√°sicas (`sa`, `pb`, `ra`, `rra`) e testar manualmente.
3. Implementar `sort_2` e `sort_3` (testar todas permuta√ß√µes).
4. Implementar `sort_4` e `sort_5` (usar estrat√©gia de mover menores para B).
5. Implementar `sort_many` com radix (√© a abordagem mais simples e confi√°vel).
6. Melhorar: implementar chunking se quiser reduzir n√∫mero de opera√ß√µes.
7. Testar exaustivamente e corrigir leaks.

## 15 ‚Äî Exemplo de fluxo de execu√ß√£o (caso 5 elementos)

Entrada: `./push_swap 3 2 5 1 4`

- Indexe: 3->2, 2->1, 5->4, 1->0, 4->3 (√≠ndices 0..4)
- Estrat√©gia de 5: enviar 0 e 1 para B (os dois menores), ordenar 3 em A, depois trazer B de volta.

Sequ√™ncia poss√≠vel (exemplo):

```
pb
pb
sa
ra
sa
pa
pa
```

Executar `./push_swap 3 2 5 1 4 | ./checker 3 2 5 1 4` deve imprimir `OK`.

ARG="3 2 1"; ./push_swap $ARG | ./checker $ARG
# 100 aleat√≥rios
ARG="$(shuf -i 0-99 | tr "\n" " ")"; ./push_swap $ARG | ./checker $ARG
# 500 aleat√≥rios
ARG="$(shuf -i 0-499 | tr "\n" " ")"; ./push_swap $ARG | ./checker $ARG

## 16 ‚Äî Documenta√ß√£o do c√≥digo-fonte (NOV/2025)

Todos os arquivos foram revisados e comentados com:

- **Header (`push_swap.h`)**: estruturas, enums e fun√ß√µes est√£o documentadas com explica√ß√µes do que cada uma faz.
- **Fun√ß√µes de parsing**: coment√°rios explicam valida√ß√£o, tokeniza√ß√£o e indexa√ß√£o.
- **Opera√ß√µes (`ops_*.c`)**: cada opera√ß√£o documenta o comportamento (swap, push, rotate).
- **Fun√ß√µes de busca/utilidade**: `find_min_value`, `find_position`, `distance_to_top`, etc. explicadas.
- **Algoritmos de ordena√ß√£o**: `sort_2`, `sort_3`, `sort_many` documentados com a estrat√©gia usada.
- **Fun√ß√µes auxiliares refatoradas**: `small_cases.c`, `pull_b.c` com coment√°rios linha por linha.

Para entender o fluxo completo, consulte `src/main.c`:
1. Parse argumentos e valida.
2. Indexa valores (0..n-1).
3. Escolhe algoritmo baseado no tamanho.
4. Executa ordena√ß√£o.
5. Libera mem√≥ria.